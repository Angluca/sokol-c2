module example;
import stdio local;
import sokol_app as sapp;
import sokol_gfx as sg;
import sokol_glue as sglue;
import sokol_log as slog;

// application state
type State struct {
    sg.Buffer vbuf;
    sg.Buffer ibuf;
    sg.Pipeline pip;
    sg.PassAction pass_action;
} State state;

type Vertex struct {
    f32 x, y, z, g, b;
}

fn void init() {
    state.pass_action.colors[0] = {
        .load_action = CLEAR,
        .clear_value = {0.0, 0.0, 1.0, 1.0}
    }
    sg.Desc desc = {
        .environment = sglue.environment(),
        //.logger = {.func = slog.func}
    } sg.setup(&desc);

    // a 2D triangle and quad in 1 vertex buffer and 1 index buffer
    Vertex[7] vertices = {
        // triangle
        {0.0, 0.55, 1.0, 0.0, 0.0},
        {0.25, 0.05, 0.0, 1.0, 0.0},
        {-0.25, 0.05, 0.0, 0.0, 1.0},

        // quad
        {-0.25, -0.05, 0.0, 0.0, 1.0},
        {0.25, -0.05, 0.0, 1.0, 0.0},
        {0.25, -0.55, 1.0, 0.0, 0.0},
        {-0.25, -0.55, 1.0, 1.0, 0.0}
    }
    u16[9] indices = {
        0, 1, 2,
        0, 1, 2, 0, 2, 3
    }
    sg.BufferDesc vbd = {
        .data = {&vertices, sizeof(vertices)},
        .label = "vertex-buffer"
    } state.vbuf = sg.makeBuffer(&vbd);
    sg.BufferDesc ibd = {
        .usage = {.index_buffer = true},
        .data = {&indices, sizeof(indices)},
        .label = "index-buffer"
    } state.ibuf = sg.makeBuffer(&ibd);

    // a shader (use separate shader sources here
    sg.ShaderDesc sd = bufferoffsetsShaderDesc(sg.queryBackend());
    sg.Shader shd = sg.makeShader(&sd);

    // a shader and pipeline to render 2D shapes
    sg.PipelineDesc pd = {
        .shader = shd,
        .index_type = UINT16,
        .layout = {
            .attrs = {
                [ATTR_BUFFEROFFSETS_POSITION] = { .format = FLOAT2 },
                [ATTR_BUFFEROFFSETS_COLOR0] = { .format = FLOAT3 },
            }
        },
        .label = "pipeline",
    } state.pip = sg.makePipeline(&pd);
}

fn void frame() {
    sg.Pass pass = {.action = state.pass_action, .swapchain = sglue.swapchain()}
    sg.beginPass(&pass);
    sg.applyPipeline(state.pip);
    // render the triangle (located at start of vertex- and index-buffer)
    sg.Bindings triangle = {
        .vertex_buffers = {[0] = state.vbuf},
        .index_buffer = state.ibuf
    } sg.applyBindings(&triangle);
    sg.draw(0, 3, 1);
    // render the quad (located after triangle data in vertex- and index-buffer)
    sg.Bindings quad = {
        .vertex_buffers = {[0] = state.vbuf},
        .index_buffer = state.ibuf,
        .vertex_buffer_offsets = {[0] = 3 * sizeof(Vertex)},
        .index_buffer_offset = 3 * sizeof(u16)
    } sg.applyBindings(&quad);
    sg.draw(0, 6, 1);
    sg.endPass();
    sg.commit();
}

fn void cleanup() {
    sg.shutdown();
}

public fn i32 main(i32 argc, char** argv) {
    sapp.Desc desc = {
        .init_cb = init,
        .frame_cb = frame,
        .cleanup_cb = cleanup,
        .width = 640,
        .height = 480,
        .window_title = "buffer offsets",
        .icon = {.sokol_default = true},
        //.logger = {.func = slog.func},
    }
    sapp.run(&desc);
    return 0;
}

